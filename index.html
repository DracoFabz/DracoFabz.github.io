<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deck Tester</title>
    <style>
        body {width: 100%; height: 100%; overflow: auto;margin: 0; font-family: Arial, sans-serif; background-color: #f0f0f0;}
        #banner {background-color: #3466af; color: #dedede; text-align: left; padding: 3px 10px; font-size: 15px; text-transform: uppercase; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;  position: fixed; width: 100%; top: 0; left: 0; z-index: 1; box-sizing: border-box;}
        #buttons-banner {background-color: #ffffff; text-align: left; padding: 5px 5px; position: fixed; width: 100%; top: 22px; left: 0; z-index: 1; box-sizing: border-box;}
        .button {background-color: #3466af; color: #dedede; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s; font-size: 12px; display: inline-block; margin: 0 1px; box-sizing: border-box;}
        .button:hover, .button:active {background-color: #4976b7;}
        #drag-container {position: fixed; top: 50px; left: 0px; right: 0px; bottom: 0px; background: url('https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Layout.png') no-repeat top left; background-size: cover; overflow: hidden; z-index: 0;}
        .card {position: absolute; cursor: pointer; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); z-index: 2; transition: transform 0.3s;}
        #popup {display: none; position: fixed; top: 50%; left: 50%; font-size: 15px; transform: translate(-50%, -50%); background-color: #ffffff; border: 2px solid grey; padding: 20px; border-radius: 20px; width: 200px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); z-index: 3;}
        #popup h2 {margin-top: 0; font-size: 15px;}
        #text-input {width: 100%; height: 100px; border: 1px solid grey; border-radius: 10px; margin: 10px -10px; padding: 10px; resize: none;}
        #popup-buttons {text-align: center;}
        .tooltip {position: absolute;background-color: rgba(0, 0, 0, 0.7);color: white;padding: 5px;border-radius: 5px;display: none; /* Hidden by default */max-width: 200px;word-wrap: break-word;z-index: 1000;}
        .tooltip.show {display: block;}
    </style>
</head>
<body>
    <div id="banner">Deck Tester V1.1</div>
    <div id="buttons-banner">
        <button class="button" id="donate-button">Donate</button>
        <button class="button" id="import-button">Import Deck</button>
        <button class="button" id="clear-deck-button">Clear Deck</button>
		<button class="button" id="mulligan-button">Mulligan</button>
    </div>
    <div id="drag-container">
    </div>
    <div id="popup">
        <h2>Importing Deck</h2>
        <p>Paste here the codes from Digimon.io</p>
        <textarea id="text-input"></textarea>
        <div id="popup-buttons">
            <button class="button" id="load-code-button">Load Code</button>
            <button class="button" id="go-back-button">Go Back</button>
        </div>
    </div>
<script>
    const donateButton = document.getElementById('donate-button');
    const importButton = document.getElementById('import-button');
    const popup = document.getElementById('popup');
    const goBackButton = document.getElementById('go-back-button');
    const loadCodeButton = document.getElementById('load-code-button');
	const mulliganButton = document.getElementById('mulligan-button');
    const clearDeckButton = document.getElementById('clear-deck-button');
    const container = document.getElementById('drag-container');
    const defaultImageUrl = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
    const diceUrl = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/dice.png';
	let currentDeckType = "Deck"; // Default deck type
    donateButton.addEventListener('click', () => {
        alert('Thanks for donation');
    });
    importButton.addEventListener('click', () => {
        popup.style.display = 'block';
    });
    goBackButton.addEventListener('click', () => {
        popup.style.display = 'none';
    });
	window.addEventListener('resize', () => {
    adjustContainerSize();
	});
    document.addEventListener('DOMContentLoaded', () => {
        adjustContainerSize();
        addDice(); 
    });
    loadCodeButton.addEventListener('click', () => {
		let currentDeckType = "Deck"; // Default deck type
		let input = document.getElementById('text-input').value.trim();
		input = input.replace(/[()]/g, '');
		const lines = input.split('\n');
		const cardEntries = [];
		lines.forEach(line => {
			line = line.trim();
			if (line.startsWith('//')) {
				if (line.toLowerCase().includes('egg deck')) {currentDeckType = "Egg";} else {currentDeckType = "Deck";}
				return;
			}
			const firstChar = line.charAt(0);
			if (!isNaN(firstChar)) {
				const parts = line.split(' ');
				const numCards = parseInt(firstChar);
				const cardCode = parts[parts.length - 1].toUpperCase().trim();
				if (!isNaN(numCards) && cardCode) {
					for (let i = 0; i < numCards; i++) {
						cardEntries.push({ code: cardCode, type: currentDeckType });
					}
				}
			}
		});
		shuffleArray(cardEntries);
		cardEntries.forEach(entry => {
			addCards(1, entry.code, entry.type);
		});
		popup.style.display = 'none';
	});
    clearDeckButton.addEventListener('click', () => {
        const elements = container.children;
        for (let i = elements.length - 1; i >= 0; i--) {
            const element = elements[i];
            if (!element.src.includes(diceUrl)) {
                container.removeChild(element);}}
    });
	mulliganButton.addEventListener('click', () => {
		const cards = Array.from(container.children).filter(child => !child.src.includes(diceUrl));
		shuffleArray(cards);
		const maxZIndex = cards.length;
		cards.forEach((card, index) => {
			card.style.zIndex = maxZIndex - index; // Adjust the Z-index for shuffling
		});
		const eggDeckCards = cards.filter(card => card.dataset.decktype === 'Egg');
		const mainDeckCards = cards.filter(card => card.dataset.decktype !== 'Egg');
		eggDeckCards.forEach(card => {
			HomeDeck(card);
		});
		const securityCards = mainDeckCards.slice(0, 5);
		securityCards.forEach(card => {
			card.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
			card.style.transition = 'none';
			card.style.transform = 'rotate(-90deg)';
		});
		MoveTo(securityCards, {
			left: container.offsetWidth * 0.04,
			top: container.offsetHeight * 0.39,
			xSpacing: 0.05,
			ySpacing: -0.22
		});
		const handCards = mainDeckCards.slice(5, 10);
		handCards.forEach(card => {
			card.src = card.dataset.originalImageUrl;
			card.style.transition = 'none';
			card.style.transform = 'rotate(0deg)';
		});
		MoveTo(handCards, {
			left: container.offsetWidth * 0.5,
			top: container.offsetHeight * 0.84,
			xSpacing: 0.8,
			ySpacing: 0
		});
		mainDeckCards.slice(10).forEach(card => {
			card.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
			card.style.transition = 'none';
			card.style.transform = 'rotate(0deg)';
			HomeDeck(card);
		});
	});
	function shuffleArray(array) {
		const shuffle = (arr) => {
			for (let i = arr.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[arr[i], arr[j]] = [arr[j], arr[i]];}};
			for (let k = 0; k < 3; k++) {shuffle(array);}
	}
	function MoveTo(cards, area) {
		let highestZIndex = 1;
		cards.forEach((card, i) => {
			const cardWidth = card.offsetWidth;
			const cardHeight = card.offsetHeight;
			const targetX = area.left + (i * (cardWidth * area.xSpacing));
			const targetY = area.top + (i * (cardHeight * area.ySpacing));
			const initialX = card.offsetLeft;
			const initialY = card.offsetTop;
			const initialVisualLeftRatio = initialX / container.offsetWidth;
			const initialVisualTopRatio = initialY / container.offsetHeight;
			card.style.zIndex = ++highestZIndex;
			card.style.transition = 'left 0.2s ease, top 0.2s ease';
			card.style.left = `${targetX}px`;
			card.style.top = `${targetY}px`;
			const onTransitionEnd = () => {
				const newVisualLeftRatio = targetX / container.offsetWidth;
				const newVisualTopRatio = targetY / container.offsetHeight;
				const hasMoved = initialX !== targetX || initialY !== targetY;
				if (hasMoved) {
					card.dataset.visualLeftRatio = newVisualLeftRatio;
					card.dataset.visualTopRatio = newVisualTopRatio;
				}
				card.style.transition = '';
				card.removeEventListener('transitionend', onTransitionEnd);
			};
			card.addEventListener('transitionend', onTransitionEnd);
		});
	}
	function CheckArea(card, areaIndex) {
		const container = document.getElementById('drag-container');
		const containerWidth = container.offsetWidth;
		const containerHeight = container.offsetHeight;
		const cardRect = card.getBoundingClientRect();
		const containerRect = container.getBoundingClientRect();
		const cardLeft = cardRect.left - containerRect.left;
		const cardTop = cardRect.top - containerRect.top;
		const cardRight = cardLeft + card.offsetWidth;
		const cardBottom = cardTop + card.offsetHeight;
		const areas = [
			{ // Trash Area [0]
				left: containerRect.width * 0.92,
				right: containerRect.width,
				top: containerRect.height * 0.25,
				bottom: containerRect.height * 0.60
			},
			{ // Security Area [1]
				left: 0,
				right: containerRect.width * 0.12,
				top: containerRect.height * 0.3,
				bottom: containerRect.height * 0.45
			},
			{ // Deck Area [2]
				left: containerRect.width * 0.92,
				right: containerRect.width,
				top: containerRect.height * 0.25,
				bottom: containerRect.height * 0.27
			},
			{ // Egg Area [3]
				left: containerRect.width * 0.13,
				right: containerRect.width * 0.11,
				top: containerRect.height * 0.87,
				bottom: containerRect.height
			},
			{ // Raising Area [4]
				left: containerRect.width * 0.13,
				right: containerRect.width * 0.19,
				top: containerRect.height * 0.87,
				bottom: containerRect.height
			}
			// Add more areas as needed
		];
		const area = areas[areaIndex];
		const isInArea = cardRight > area.left && cardLeft < area.right &&
						 cardBottom > area.top && cardTop < area.bottom;
		return isInArea;
	}
	function checkCardRegion(card) {
		if (card.src === 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/dice.png') {} else {
		if (CheckArea(card, 1) || CheckArea(card, 2) || CheckArea(card, 3)) {
			card.src = defaultImageUrl;} else {card.src = card.dataset.originalImageUrl || defaultImageUrl;}
		if (CheckArea(card, 1)) {
			let rotation = parseInt(card.style.transform.replace('rotate(', '').replace('deg)', '')) || 0;
			if (rotation % 360 === 0) {rotation -= 90;}
			rotation = (rotation - 360) % 360;
			card.style.transform = `rotate(${rotation}deg)`;}
		if (CheckArea(card, 4) || CheckArea(card, 0)) {
			let rotation = parseInt(card.style.transform.replace('rotate(', '').replace('deg)', '')) || 0;
			if (rotation % 360 === 0) {rotation -= 0;} else {rotation += 90;}
			rotation = (rotation - 360) % 360;
			card.style.transform = `rotate(${rotation}deg)`;
		}}
	}

    let highestZIndex = 1;
	function snapToCard(card) {
		const allCards = document.querySelectorAll('.card');
		allCards.forEach(otherCard => {
			if (card !== otherCard) {
				const cardCenterX = card.offsetLeft + card.offsetWidth / 2;
				const cardCenterY = card.offsetTop + card.offsetHeight / 2;
				const otherCardCenterX = otherCard.offsetLeft + otherCard.offsetWidth / 2;
				const otherCardCenterY = (otherCard.offsetTop + otherCard.offsetHeight / 2) * 0.93;
				const distanceX = Math.abs(cardCenterX - otherCardCenterX);
				const distanceY = Math.abs(cardCenterY - otherCardCenterY);
				const thresholdX = otherCard.offsetWidth * 0.05;
				const thresholdY = otherCard.offsetHeight * 0.05;
				if (distanceX < thresholdX && distanceY < thresholdY) {
					const snapX = otherCard.offsetLeft;
					const snapY = otherCard.offsetTop - otherCard.offsetHeight * 0.15;
					card.style.left = `${snapX}px`;
					card.style.top = `${snapY}px`;
					const visualLeftRatio = snapX / container.offsetWidth;
					const visualTopRatio = snapY / container.offsetHeight;
					card.dataset.visualLeftRatio = visualLeftRatio;
					card.dataset.visualTopRatio = visualTopRatio;
				}
			}
		});
	}
	function snapToPosition(card) {
		const positions = [
			{ x: 0.115, y: 0.825 }, //Digitama deck
			{ x: 0.237, y: 0.825 }, //Hatched egg
			{ x: 0.9163, y: 0.255 }, //Main Deck
			{ x: 0.9163, y: 0.543 } //Trash
		];
		positions.forEach(position => {
			const cardCenterX = card.offsetLeft + card.offsetWidth / 2;
			const cardCenterY = card.offsetTop + card.offsetHeight / 2;
			const distanceX = Math.abs(cardCenterX - (container.offsetWidth * position.x));
			const distanceY = Math.abs(cardCenterY - (container.offsetHeight * position.y));
			const thresholdX = card.offsetWidth * 0.1;
			const thresholdY = card.offsetHeight * 0.1;
			if (distanceX < thresholdX && distanceY < thresholdY) {
				const snapX = (container.offsetWidth * position.x) - card.offsetWidth / 2;
				const snapY = (container.offsetHeight * position.y) - card.offsetHeight / 2;
				card.style.left = `${snapX}px`;
				card.style.top = `${snapY}px`;
				const visualLeftRatio = snapX / container.offsetWidth;
				const visualTopRatio = snapY / container.offsetHeight;
				card.dataset.visualLeftRatio = visualLeftRatio;
				card.dataset.visualTopRatio = visualTopRatio;
			}
		});
	}

	function makeDraggable(element) {
    let isMoving = false;
    let startX, startY, initialX, initialY;
    let longPressTimeout;
    
    // Handle single tap
    element.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {  // Single touch
            e.preventDefault();  // Prevent default behavior like scrolling
            isMoving = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            initialX = element.offsetLeft;
            initialY = element.offsetTop;
            highestZIndex++;
            element.style.zIndex = highestZIndex;
            
            // Long press detection
            longPressTimeout = setTimeout(() => {
                showCardInfo({ currentTarget: element });
            }, 2000);
            
            document.addEventListener('touchmove', moveElement);
            document.addEventListener('touchend', stopMove);
        }
    });
    
    function moveElement(e) {
        if (isMoving) {
            element.style.zIndex = ++highestZIndex;
            const dx = e.touches[0].clientX - startX;
            const dy = e.touches[0].clientY - startY;
            const newX = initialX + dx;
            const newY = initialY + dy;
            const minY = 0;
            const maxX = container.offsetWidth - element.offsetWidth;
            const maxY = 1.1 * container.offsetHeight - element.offsetHeight;
            if (newX >= 0 && newX <= maxX && newY >= minY && newY <= maxY) {
                element.style.left = newX + 'px';
                element.style.top = newY + 'px';
                const visualLeftRatio = newX / container.offsetWidth;
                const visualTopRatio = newY / container.offsetHeight;
                element.dataset.visualLeftRatio = visualLeftRatio;
                element.dataset.visualTopRatio = visualTopRatio;
                checkCardRegion(element);
                snapToCard(element);
                snapToPosition(element);
                const snappedLeft = parseFloat(element.style.left);
                const snappedTop = parseFloat(element.style.top);
                element.dataset.visualLeftRatio = snappedLeft / container.offsetWidth;
                element.dataset.visualTopRatio = snappedTop / container.offsetHeight;
            }
        }
    }

    function stopMove(e) {
        isMoving = false;
        clearTimeout(longPressTimeout);  // Clear long press if move occurred
        document.removeEventListener('touchmove', moveElement);
        document.removeEventListener('touchend', stopMove);
    }

    // Double tap for rotation
    let lastTapTime = 0;
    element.addEventListener('touchend', (e) => {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTapTime;
        clearTimeout(longPressTimeout);  // Clear long press if touch ended
        if (tapLength < 300 && tapLength > 0) {
            // Double tap detected
            element.style.zIndex = ++highestZIndex;
            let rotation = parseInt(element.style.transform.replace('rotate(', '').replace('deg)', '')) || 0;
            if (element.src === 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/dice.png') {} else {
            if (CheckArea(element, 0)) {
                element.style.transform = 'rotate(0deg)';
                HomeDeck(element);
                element.style.zIndex = 1;
                element.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
            } else {
                if (rotation % 360 === 0) {
                    rotation -= 90;
                } else {
                    rotation += 90;
                }
                rotation = (rotation - 360) % 360;
                element.style.transform = `rotate(${rotation}deg)`;
            }}
        }
        lastTapTime = currentTime;
    });

    element.dataset.originalImageUrl = element.src;
}

    function addDice() {
        const dice = document.createElement('img');
		const containerWidth = container.offsetWidth;
        dice.src = diceUrl;
        dice.className = 'card';
        dice.style.width = (containerWidth / 25) + 'px';
        dice.style.height = 'auto';
        dice.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
        container.appendChild(dice);
        makeDraggable(dice);
        centerDice(dice);
    }
    function centerDice(dice) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const diceWidth = dice.offsetWidth;
        const diceHeight = dice.offsetHeight;
        const defaultCenterXRatio = 0.483;
        const defaultCenterYRatio = 0.024;
        dice.dataset.defaultCenterXRatio = defaultCenterXRatio;
        dice.dataset.defaultCenterYRatio = defaultCenterYRatio;
        dice.dataset.visualLeftRatio = defaultCenterXRatio;
        dice.dataset.visualTopRatio = defaultCenterYRatio;
        updateDicePosition(dice);
    }
    function adjustContainerSize() {
		const backgroundImg = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Layout.png';
		const img = new Image();
		img.src = backgroundImg;
		img.onload = function() {
			const imgWidth = img.width;
			const imgHeight = img.height;
			const windowWidth = window.innerWidth;
			const windowHeight = window.innerHeight - 76;
			const imgAspectRatio = imgWidth / imgHeight;
			const windowAspectRatio = windowWidth / windowHeight;
			let newWidth, newHeight;
			if (windowAspectRatio > imgAspectRatio) {
				newHeight = windowHeight;
				newWidth = newHeight * imgAspectRatio;
			} else {
				newWidth = windowWidth;
				newHeight = newWidth / imgAspectRatio;
			}
			container.style.width = `${newWidth}px`;
			container.style.height = `${newHeight}px`;
			container.style.position = 'absolute';
			container.style.left = '50%';
			container.style.transform = 'translateX(-50%)';
			adjustCardSize();
			adjustDiceSize();
		};
	}
	function adjustCardSize() {
        const cards = document.querySelectorAll('.card');
		const containerWidth = container.offsetWidth;
        cards.forEach(card => {
            if (!card.src.includes(diceUrl)) { 
                card.style.width = (containerWidth / 10) + 'px';
                updateCardPosition(card);
            }
        });
    }
    function adjustDiceSize() {
        const dice = document.querySelectorAll('.card');
		const containerWidth = container.offsetWidth;
        dice.forEach(d => {
            if (d.src.includes(diceUrl)) { 
                d.style.width = (containerWidth / 25) + 'px';
                updateDicePosition(d);
            }
        });
    }
	function updateDicePosition(dice) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const defaultCenterXRatio = parseFloat(dice.dataset.defaultCenterXRatio);
        const defaultCenterYRatio = parseFloat(dice.dataset.defaultCenterYRatio);
        const visualLeftRatio = parseFloat(dice.dataset.visualLeftRatio);
        const visualTopRatio = parseFloat(dice.dataset.visualTopRatio);
        const diceWidth = dice.offsetWidth;
        const diceHeight = dice.offsetHeight;
        const newX = visualLeftRatio * containerWidth - defaultCenterXRatio;
        const newY = visualTopRatio * containerHeight - defaultCenterYRatio;
        dice.style.left = newX + 'px';
        dice.style.top = newY + 'px';
    }
	function updateCardPosition(card) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const defaultCenterXRatio = parseFloat(card.dataset.defaultCenterXRatio);
        const defaultCenterYRatio = parseFloat(card.dataset.defaultCenterYRatio);
        const visualLeftRatio = parseFloat(card.dataset.visualLeftRatio);
        const visualTopRatio = parseFloat(card.dataset.visualTopRatio);
        const cardWidth = card.offsetWidth;
        const cardHeight = card.offsetHeight;
        const newX = visualLeftRatio * containerWidth - defaultCenterXRatio;
        const newY = visualTopRatio * containerHeight - defaultCenterYRatio;
        card.style.left = newX + 'px';
        card.style.top = newY + 'px';
    }
    function addCards(num, code, type) {
		const apiUrl = `https://digimoncard.io/api/search.php?card=${code}`;
			ConectToServer(apiUrl)
			.then(description => {
				for (let i = 0; i < num; i++) {
					GetCardInfo(code, type, description);
				}
			})
			.catch(error => {
				console.error('Error fetching card description:', error);
			});
		popup.style.display = 'none';
	}
	function ConectToServer(apiUrl) {
		return fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(apiUrl))
			.then(response => response.text())
			.then(responseText => {
				const data = JSON.parse(responseText);
				if (data.length > 0) {
					const cardData = data[0];
					return {
						name: cardData.name,
						main_effect: cardData.main_effect,
						source_effect: cardData.source_effect};
				} else {return {
						name: 'Unknown',
						main_effect: 'No effect available',
						source_effect: 'No effect available'
					};
				}
			})
			.catch(() => ({
				name: 'Error',
				main_effect: 'Failed to fetch effect',
				source_effect: 'Failed to fetch effect'
			}));
	}
	function GetCardInfo(code, type, description) {
		const containerWidth = container.offsetWidth;
		const card = document.createElement('img');
		const imageUrl = `https://images.digimoncard.io/images/cards/${code}.jpg`;
		const defaultImageUrl = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
		const img = new Image();
		img.onload = function() {
			card.src = imageUrl;
			card.dataset.originalImageUrl = imageUrl;
			card.dataset.name = description.name;
			card.dataset.mainEffect = description.main_effect;
			card.dataset.sourceEffect = description.source_effect;
		};
		img.onerror = function() {
			card.src = defaultImageUrl;
			card.dataset.originalImageUrl = defaultImageUrl;
			card.dataset.name = description.name;
			card.dataset.mainEffect = description.main_effect;
			card.dataset.sourceEffect = description.source_effect;
		};
		img.src = imageUrl;
		card.className = 'card';
		card.style.width = (containerWidth / 10) + 'px';
		card.style.height = 'auto';
		card.dataset.decktype = type;
		container.appendChild(card);
		HomeDeck(card);
		makeDraggable(card);
		setupHoverInfo(card);
	}
	function HomeDeck(card) {
		const containerWidth = container.offsetWidth;
		const containerHeight = container.offsetHeight;
		const cardWidth = card.offsetWidth;
		const cardHeight = card.offsetHeight;
		let defaultCenterXRatio, defaultCenterYRatio;
		if (card.dataset.decktype === "Egg") 
			{defaultCenterXRatio = 0.065;defaultCenterYRatio = 0.708;} 
			else 
			{defaultCenterXRatio = 0.867;defaultCenterYRatio = 0.137;}
		const defaultCenterX = containerWidth * defaultCenterXRatio;
		const defaultCenterY = containerHeight * defaultCenterYRatio;
		card.dataset.defaultCenterXRatio = defaultCenterXRatio;
		card.dataset.defaultCenterYRatio = defaultCenterYRatio;
		card.dataset.visualLeftRatio = defaultCenterXRatio;
		card.dataset.visualTopRatio = defaultCenterYRatio;
		card.style.transition = 'transform 0.3s';
		card.style.transform = 'rotate(0deg)';
		card.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
		updateCardPosition(card);
	}
</script>
</body>
</html>