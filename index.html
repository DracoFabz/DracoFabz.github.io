<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deck Tester</title>
    <style>
        body {width: 100%; height: 100%; overflow: auto;margin: 0; font-family: Arial, sans-serif; background-color: #f0f0f0;}
        #banner {background-color: #3466af; color: #dedede; text-align: left; padding: 1.5% 1.5%; font-size: 2.5vw; text-transform: uppercase; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;  position: fixed; width: 100%; top: 0; left: 0; z-index: 1; box-sizing: border-box;}
        #buttons-banner {background-color: #ffffff; text-align: left; padding: 1% 2%; position: fixed; width: 100%; top: calc(2% + 1.5% + 1em); left: 0; z-index: 1; box-sizing: border-box;}
        .button {background-color: #3466af; color: #dedede; border: none; border-radius: 20px; cursor: pointer; transition: background-color 0.3s; font-size: 0.7vw; display: inline-block; margin: 0 5px; box-sizing: border-box;}
        .button:hover, .button:active {background-color: #4976b7;}
        #drag-container {position: fixed; top: calc(2% + 1.5% + 1em + 3 * (3vw)); left: 5px; right: 5px; bottom: 5px; background: url('https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Layout.png') no-repeat top left; background-size: cover; overflow: hidden; z-index: 0;}
        .card {position: absolute; cursor: pointer; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); z-index: 2; transition: transform 0.3s;}
        #popup {display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #ffffff; border: 2px solid grey; padding: 20px; border-radius: 20px; width: 300px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); z-index: 3;}
        #popup h2 {margin-top: 0;}
        #text-input {width: 100%; height: 100px; border: 1px solid grey; border-radius: 10px; margin: 10px -10px; padding: 10px; resize: none;}
        #popup-buttons {text-align: center;}
        .tooltip {position: absolute;background-color: rgba(0, 0, 0, 0.7);color: white;padding: 10px;border-radius: 5px;display: none; /* Hidden by default */max-width: 200px;word-wrap: break-word;z-index: 1000;}
        .tooltip.show {display: block;}
    </style>
</head>
<body>
    <div id="banner">Deck Tester</div>
    <div id="buttons-banner">
        <button class="button" id="donate-button">Donate</button>
        <button class="button" id="import-button">Import Deck</button>
        <button class="button" id="clear-deck-button">Clear Deck</button>
		<button class="button" id="mulligan-button">Mulligan</button>
    </div>
    <div id="drag-container">
    </div>
    <div id="popup">
        <h2>Importing Deck</h2>
        <p>Paste here the codes from Digimon.io</p>
        <textarea id="text-input"></textarea>
        <div id="popup-buttons">
            <button class="button" id="load-code-button">Load Code</button>
            <button class="button" id="go-back-button">Go Back</button>
        </div>
    </div>
<script>
    const donateButton = document.getElementById('donate-button');
    const importButton = document.getElementById('import-button');
    const popup = document.getElementById('popup');
    const goBackButton = document.getElementById('go-back-button');
    const loadCodeButton = document.getElementById('load-code-button');
	const mulliganButton = document.getElementById('mulligan-button');
    const clearDeckButton = document.getElementById('clear-deck-button');
    const container = document.getElementById('drag-container');
    const defaultImageUrl = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
    const diceUrl = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/dice.png';
	let currentDeckType = "Deck"; // Default deck type
    donateButton.addEventListener('click', () => {
        alert('Thanks for donation');
    });
    importButton.addEventListener('click', () => {
        popup.style.display = 'block';
    });
    goBackButton.addEventListener('click', () => {
        popup.style.display = 'none';
    });
	window.addEventListener('resize', () => {
        requestAnimationFrame(() => {
            adjustCardSize();
            adjustDiceSize();
            adjustContainerSize();
            adjustButtonBanner();
        });
    });
    document.addEventListener('DOMContentLoaded', () => {
        adjustCardSize();
        adjustDiceSize();
        adjustContainerSize();
        adjustButtonBanner();
        addDice(); 
    });
    loadCodeButton.addEventListener('click', () => {
		let currentDeckType = "Deck"; // Default deck type
		let input = document.getElementById('text-input').value.trim();
		input = input.replace(/[()]/g, '');
		const lines = input.split('\n');
		const cardEntries = [];
		lines.forEach(line => {
			line = line.trim();
			if (line.startsWith('//')) {
				if (line.toLowerCase().includes('egg deck')) {currentDeckType = "Egg";} else {currentDeckType = "Deck";}
				return;
			}
			const firstChar = line.charAt(0);
			if (!isNaN(firstChar)) {
				const parts = line.split(' ');
				const numCards = parseInt(firstChar);
				const cardCode = parts[parts.length - 1].toUpperCase().trim();
				if (!isNaN(numCards) && cardCode) {
					for (let i = 0; i < numCards; i++) {
						cardEntries.push({ code: cardCode, type: currentDeckType });
					}
				}
			}
		});
		shuffleArray(cardEntries);
		cardEntries.forEach(entry => {
			addCards(1, entry.code, entry.type);
		});
		popup.style.display = 'none';
	});
    clearDeckButton.addEventListener('click', () => {
        const elements = container.children;
        for (let i = elements.length - 1; i >= 0; i--) {
            const element = elements[i];
            if (!element.src.includes(diceUrl)) {
                container.removeChild(element);}}
    });
	mulliganButton.addEventListener('click', () => {
		const cards = Array.from(container.children).filter(child => !child.src.includes(diceUrl));
		shuffleArray(cards);
		const maxZIndex = cards.length;
		cards.forEach((card, index) => {
			card.style.zIndex = maxZIndex - index; // Adjust the Z-index for shuffling
		});
		const eggDeckCards = cards.filter(card => card.dataset.decktype === 'Egg');
		const mainDeckCards = cards.filter(card => card.dataset.decktype !== 'Egg');
		eggDeckCards.forEach(card => {
			HomeDeck(card);
		});
		const securityCards = mainDeckCards.slice(0, 5);
		securityCards.forEach(card => {
			card.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
			card.style.transform = 'rotate(-90deg)';
		});
		MoveTo(securityCards, {
			left: container.offsetWidth * 0.04,
			top: container.offsetHeight * 0.18,
			xSpacing: 0.05,
			ySpacing: 0.22
		});
		const handCards = mainDeckCards.slice(5, 10);
		handCards.forEach(card => {
			card.src = card.dataset.originalImageUrl;
			card.style.transform = 'rotate(0deg)';
		});
		MoveTo(handCards, {
			left: container.offsetWidth * 0.5,
			top: container.offsetHeight * 0.84,
			xSpacing: 0.9,
			ySpacing: 0
		});
		mainDeckCards.slice(10).forEach(card => {
			card.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
			card.style.transform = 'rotate(0deg)';
			HomeDeck(card);
		});
	});
	function shuffleArray(array) {
    const shuffle = (arr) => {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];}};
		for (let k = 0; k < 3; k++) {shuffle(array);}
}
	function MoveTo(cards, area) {
    cards.forEach((card, i) => {
		let highestZIndex = 1;
        const cardWidth = card.offsetWidth;
        const cardHeight = card.offsetHeight;
        const positionX = area.left + (i * (cardWidth * area.xSpacing));
        const positionY = area.top + (i * (cardHeight * area.ySpacing));
        card.style.transition = 'left 0s ease, top 0s ease'; 
        card.style.left = `${positionX}px`;
        card.style.top = `${positionY}px`;
		card.style.zIndex = ++highestZIndex;
        card.addEventListener('transitionend', () => {
            updateCardPosition(card);
        }, { once: true });
    });
}
    function updateCardPosition(card) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const defaultCenterXRatio = parseFloat(card.dataset.defaultCenterXRatio);
        const defaultCenterYRatio = parseFloat(card.dataset.defaultCenterYRatio);
        const visualLeftRatio = parseFloat(card.dataset.visualLeftRatio);
        const visualTopRatio = parseFloat(card.dataset.visualTopRatio);
        const cardWidth = card.offsetWidth;
        const cardHeight = card.offsetHeight;
        const newX = visualLeftRatio * containerWidth - defaultCenterXRatio;
        const newY = visualTopRatio * containerHeight - defaultCenterYRatio;
        card.style.left = newX + 'px';
        card.style.top = newY + 'px';
    }
	function CheckArea(card, areaIndex) {
		const container = document.getElementById('drag-container');
		const containerWidth = container.offsetWidth;
		const containerHeight = container.offsetHeight;
		const cardRect = card.getBoundingClientRect();
		const containerRect = container.getBoundingClientRect();
		const cardLeft = cardRect.left - containerRect.left;
		const cardTop = cardRect.top - containerRect.top;
		const cardRight = cardLeft + card.offsetWidth;
		const cardBottom = cardTop + card.offsetHeight;
		const areas = [
			{ // Trash Area [0]
				left: containerRect.width * 0.92,
				right: containerRect.width,
				top: containerRect.height * 0.25,
				bottom: containerRect.height * 0.60
			},
			{ // Security Area [1]
				left: 0,
				right: containerRect.width * 0.12,
				top: containerRect.height * 0.3,
				bottom: containerRect.height * 0.45
			},
			{ // Deck Area [2]
				left: containerRect.width * 0.92,
				right: containerRect.width,
				top: containerRect.height * 0.25,
				bottom: containerRect.height * 0.27
			},
			{ // Egg Area [3]
				left: containerRect.width * 0.13,
				right: containerRect.width * 0.11,
				top: containerRect.height * 0.87,
				bottom: containerRect.height
			},
			{ // Raising Area [4]
				left: containerRect.width * 0.13,
				right: containerRect.width * 0.19,
				top: containerRect.height * 0.87,
				bottom: containerRect.height
			}
			// Add more areas as needed
		];
		const area = areas[areaIndex];
		const isInArea = cardRight > area.left && cardLeft < area.right &&
						 cardBottom > area.top && cardTop < area.bottom;
		return isInArea;
	}

	function checkCardRegion(card) {
		if (CheckArea(card, 1) || CheckArea(card, 2) || CheckArea(card, 3)) {
			card.src = defaultImageUrl;} else {card.src = card.dataset.originalImageUrl || defaultImageUrl;}
		if (CheckArea(card, 1)) {
			let rotation = parseInt(card.style.transform.replace('rotate(', '').replace('deg)', '')) || 0;
			if (rotation % 360 === 0) {rotation -= 90;}
			rotation = (rotation - 360) % 360;
			card.style.transform = `rotate(${rotation}deg)`;}
		if (CheckArea(card, 4) || CheckArea(card, 0)) {
			let rotation = parseInt(card.style.transform.replace('rotate(', '').replace('deg)', '')) || 0;
			if (rotation % 360 === 0) {rotation -= 0;} else {rotation += 90;}
			rotation = (rotation - 360) % 360;
			card.style.transform = `rotate(${rotation}deg)`;
		}
	}
    let highestZIndex = 1;
    function makeDraggable(element) {
    let isMoving = false;
    let startX, startY, initialX, initialY;
    element.addEventListener('mousedown', (e) => {
        isMoving = true;
        startX = e.clientX;
        startY = e.clientY;
        initialX = element.offsetLeft;
        initialY = element.offsetTop;
        highestZIndex++;
        element.style.zIndex = highestZIndex;
        document.addEventListener('mousemove', moveElement);
        document.addEventListener('mouseup', stopMove);
    });
        function moveElement(e) {
        if (isMoving) {
			element.style.zIndex = ++highestZIndex;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const newX = initialX + dx;
            const newY = initialY + dy;
            const minY = 0;
            const maxX = container.offsetWidth - element.offsetWidth;
            const maxY = 1.1 * container.offsetHeight - element.offsetHeight;
            if (newX >= 0 && newX <= maxX && newY >= minY && newY <= maxY) {
                element.style.left = newX + 'px';
                element.style.top = newY + 'px';
                const visualLeftRatio = newX / container.offsetWidth;
                const visualTopRatio = newY / container.offsetHeight;
                element.dataset.visualLeftRatio = visualLeftRatio;
                element.dataset.visualTopRatio = visualTopRatio;
                checkCardRegion(element);
            }
        }
    }
    function stopMove() {
        isMoving = false;
		element.style.zIndex = ++highestZIndex;
        document.removeEventListener('mousemove', moveElement);
        document.removeEventListener('mouseup', stopMove);
    }
    element.addEventListener('dblclick', () => {
	element.style.zIndex = ++highestZIndex;
    let rotation = parseInt(element.style.transform.replace('rotate(', '').replace('deg)', '')) || 0;

    if (CheckArea(element, 0)) {
        element.style.transform = 'rotate(0deg)';
        HomeDeck(element);
        element.style.zIndex = 1;
        element.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
    } else {
        if (rotation % 360 === 0) {
            rotation -= 90;
        } else {
            rotation += 90;
        }
        rotation = (rotation - 360) % 360;
        element.style.transform = `rotate(${rotation}deg)`;
    }
    showCardInfo({ currentTarget: element });
});
	element.dataset.originalImageUrl = element.src;
    }
    function addDice() {
        const dice = document.createElement('img');
        dice.src = diceUrl;
        dice.className = 'card';
        dice.style.width = (window.innerWidth / 25) + 'px';
        dice.style.height = 'auto';
        dice.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
        container.appendChild(dice);
        makeDraggable(dice);
        centerDice(dice);
    }
    function centerDice(dice) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const diceWidth = dice.offsetWidth;
        const diceHeight = dice.offsetHeight;
        const defaultCenterXRatio = 0.483;
        const defaultCenterYRatio = 0.024;
        dice.dataset.defaultCenterXRatio = defaultCenterXRatio;
        dice.dataset.defaultCenterYRatio = defaultCenterYRatio;
        dice.dataset.visualLeftRatio = defaultCenterXRatio;
        dice.dataset.visualTopRatio = defaultCenterYRatio;
        updateDicePosition(dice);
    }
    function updateDicePosition(dice) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const defaultCenterXRatio = parseFloat(dice.dataset.defaultCenterXRatio);
        const defaultCenterYRatio = parseFloat(dice.dataset.defaultCenterYRatio);
        const visualLeftRatio = parseFloat(dice.dataset.visualLeftRatio);
        const visualTopRatio = parseFloat(dice.dataset.visualTopRatio);
        const diceWidth = dice.offsetWidth;
        const diceHeight = dice.offsetHeight;
        const newX = visualLeftRatio * containerWidth - defaultCenterXRatio;
        const newY = visualTopRatio * containerHeight - defaultCenterYRatio;
        dice.style.left = newX + 'px';
        dice.style.top = newY + 'px';
    }
    function adjustCardSize() {
        const cards = document.querySelectorAll('.card');
        cards.forEach(card => {
            if (!card.src.includes(diceUrl)) { 
                card.style.width = (window.innerWidth / 10) + 'px';
                updateCardPosition(card);
            }
        });
    }
    function adjustDiceSize() {
        const dice = document.querySelectorAll('.card'); 
        dice.forEach(d => {
            if (d.src.includes(diceUrl)) { 
                d.style.width = (window.innerWidth / 25) + 'px';
                updateDicePosition(d);
            }
        });
    }
    function adjustContainerSize() {
        const backgroundImg = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Layout.png';
        const img = new Image();
        img.src = backgroundImg;
        img.onload = function() {
            const imgWidth = img.width;
            const imgHeight = img.height;
            container.style.width = `calc(100% - 10px)`;
            container.style.height = `calc((100vw / ${imgWidth}) * ${imgHeight})`;
            Array.from(container.getElementsByClassName('card')).forEach(element => {
                if (element.src.includes(diceUrl)) {
                    updateDicePosition(element);
                } else {
                    updateCardPosition(element);
                }
            });
        };
    }
	function adjustButtonBanner() {
        const banner = document.getElementById('banner');
        const buttonsBanner = document.getElementById('buttons-banner');
        const bannerHeight = banner.offsetHeight;
        const buttons = document.querySelectorAll('.button');
        buttonsBanner.style.top = `${bannerHeight + 10}px`;
        buttonsBanner.style.height = `${bannerHeight}px`;
        buttons.forEach(button => {
            button.style.height = `${0.7 * bannerHeight}px`;
            button.style.lineHeight = `${0.7 * bannerHeight}px`;
            button.style.fontSize = `${0.25 * bannerHeight}px`;
        });
    }
    
function addCards(num, code, type) {
    const apiUrl = `https://digimoncard.io/api/search.php?card=${code}`;
        ConectToServer(apiUrl)
        .then(description => {
            for (let i = 0; i < num; i++) {
                GetCardInfo(code, type, description);
            }
        })
        .catch(error => {
            console.error('Error fetching card description:', error);
        });
    popup.style.display = 'none';
}
function ConectToServer(apiUrl) {
    return fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(apiUrl))
        .then(response => response.text())
        .then(responseText => {
            const data = JSON.parse(responseText);
            if (data.length > 0) {
                const cardData = data[0];
                return {
                    name: cardData.name,
                    main_effect: cardData.main_effect,
                    source_effect: cardData.source_effect};
            } else {return {
                    name: 'Unknown',
                    main_effect: 'No effect available',
                    source_effect: 'No effect available'
                };
            }
        })
        .catch(() => ({
            name: 'Error',
            main_effect: 'Failed to fetch effect',
            source_effect: 'Failed to fetch effect'
        }));
}
function GetCardInfo(code, type, description) {
    const card = document.createElement('img');
    const imageUrl = `https://images.digimoncard.io/images/cards/${code}.jpg`;
    const defaultImageUrl = 'path/to/default/image.jpg'; // Define the path to the default image
    const img = new Image();
    img.onload = function() {
        card.src = imageUrl;
        card.dataset.originalImageUrl = imageUrl;
        card.dataset.name = description.name;
        card.dataset.mainEffect = description.main_effect;
        card.dataset.sourceEffect = description.source_effect;
    };
    img.onerror = function() {
        card.src = defaultImageUrl;
        card.dataset.originalImageUrl = defaultImageUrl;
        card.dataset.name = description.name;
        card.dataset.mainEffect = description.main_effect;
        card.dataset.sourceEffect = description.source_effect;
    };
    img.src = imageUrl;
    card.className = 'card';
    card.style.width = (window.innerWidth / 10) + 'px';
    card.style.height = 'auto';
    card.dataset.decktype = type;  // Save the deck type in the card attributes
    container.appendChild(card);
	HomeDeck(card);
    makeDraggable(card);
    setupCardTooltips(card);
}

function HomeDeck(card) {
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight;
    const cardWidth = card.offsetWidth;
    const cardHeight = card.offsetHeight;
    let defaultCenterXRatio, defaultCenterYRatio;
    if (card.dataset.decktype === "Egg") 
		{defaultCenterXRatio = 0.065;defaultCenterYRatio = 0.708;} 
		else 
		{defaultCenterXRatio = 0.875;defaultCenterYRatio = 0.14;}
	const defaultCenterX = containerWidth * defaultCenterXRatio;
    const defaultCenterY = containerHeight * defaultCenterYRatio;
    card.dataset.defaultCenterXRatio = defaultCenterXRatio;
    card.dataset.defaultCenterYRatio = defaultCenterYRatio;
    card.dataset.visualLeftRatio = defaultCenterXRatio;
    card.dataset.visualTopRatio = defaultCenterYRatio;
	card.style.transform = 'rotate(0deg)';
	card.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
    updateCardPosition(card);
}
	function setupCardTooltips(card) {
		const tooltip = document.createElement('div');
		tooltip.className = 'tooltip';
		document.body.appendChild(tooltip);
		let hoverTimeout;
		card.addEventListener('mouseenter', event => {
			hoverTimeout = setTimeout(() => {
				showTooltip(event, tooltip);
			}, 3000);
		});
		card.addEventListener('mouseleave', () => {
			clearTimeout(hoverTimeout);
			hideTooltip(tooltip);
		});
	}
	function setupCardTooltips(card) {
		let hoverTimeout;
		card.addEventListener('mouseenter', event => {
			hoverTimeout = setTimeout(() => {
				showCardInfo(event);
			}, 3000); // Wait 3 seconds before showing the message
		});
		card.addEventListener('mouseleave', () => {
			clearTimeout(hoverTimeout); // Clear timeout if the mouse leaves before 3 seconds
		});
	}
	function showCardInfo(event) {
		const card = event.currentTarget;
			const message = `
${card.dataset.name}\n
${card.dataset.mainEffect}\n
${card.dataset.sourceEffect}
			`;
			alert(message);
	}
</script>
</body>
</html>