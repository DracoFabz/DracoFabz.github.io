<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deck Tester</title>
    <style>
        body {width: 100%; height: 100%; overflow: auto;margin: 0; font-family: Arial, sans-serif; background-color: #f0f0f0;}
        #banner {background-color: #3466af; color: #dedede; text-align: left; padding: 1.5% 1.5%; font-size: 2.5vw; text-transform: uppercase; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;  position: fixed; width: 100%; top: 0; left: 0; z-index: 1; box-sizing: border-box;}
        #buttons-banner {background-color: #ffffff; text-align: left; padding: 1% 2%; position: fixed; width: 100%; top: calc(2% + 1.5% + 1em); left: 0; z-index: 1; box-sizing: border-box;}
        .button {background-color: #3466af; color: #dedede; border: none; border-radius: 20px; cursor: pointer; transition: background-color 0.3s; font-size: 0.7vw; display: inline-block; margin: 0 5px; box-sizing: border-box;}
        .button:hover, .button:active {background-color: #4976b7;}
        #drag-container {position: fixed; top: calc(2% + 1.5% + 1em + 3 * (3vw)); left: 5px; right: 5px; bottom: 5px; background: url('https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Layout.png') no-repeat top left; background-size: cover; overflow: hidden; z-index: 0;}
        .card {position: absolute; cursor: pointer; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); z-index: 2; transition: transform 0.3s;}
        #popup {display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #ffffff; border: 2px solid grey; padding: 20px; border-radius: 20px; width: 300px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); z-index: 3;}
        #popup h2 {margin-top: 0;}
        #text-input {width: 100%; height: 100px; border: 1px solid grey; border-radius: 10px; margin: 10px 0; padding: 10px; resize: none;}
        #popup-buttons {text-align: center;}
        .tooltip {position: absolute;background-color: rgba(0, 0, 0, 0.7);color: white;padding: 10px;border-radius: 5px;display: none; /* Hidden by default */max-width: 200px;word-wrap: break-word;z-index: 1000;}
        .tooltip.show {display: block;}
    </style>
</head>
<body>
    <div id="banner">Deck Tester</div>
    <div id="buttons-banner">
        <button class="button" id="donate-button">Donate</button>
        <button class="button" id="import-button">Import Deck</button>
        <button class="button" id="clear-deck-button">Clear Deck</button>
		<button class="button" id="mulligan-button">Mulligan</button>
    </div>
    <div id="drag-container">
    </div>
    <div id="popup">
        <h2>Importing Deck</h2>
        <p>Paste here the codes from Digimon.io</p>
        <textarea id="text-input"></textarea>
        <div id="popup-buttons">
            <button class="button" id="load-code-button">Load Code</button>
            <button class="button" id="go-back-button">Go Back</button>
        </div>
    </div>
<script>
    const donateButton = document.getElementById('donate-button');
    const importButton = document.getElementById('import-button');
    const popup = document.getElementById('popup');
    const goBackButton = document.getElementById('go-back-button');
    const loadCodeButton = document.getElementById('load-code-button');
	const mulliganButton = document.getElementById('mulligan-button');
    const clearDeckButton = document.getElementById('clear-deck-button');
    const container = document.getElementById('drag-container');
    const defaultImageUrl = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
    const diceUrl = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/dice.png';
	let currentDeckType = "Deck"; // Default deck type
    donateButton.addEventListener('click', () => {
        alert('Thanks for donation');
    });
    importButton.addEventListener('click', () => {
        popup.style.display = 'block';
    });
    goBackButton.addEventListener('click', () => {
        popup.style.display = 'none';
    });
    loadCodeButton.addEventListener('click', () => {
		let currentDeckType = "Deck"; // Default deck type
			const input = document.getElementById('text-input').value.trim();
			const lines = input.split('\n');
			const cardEntries = [];
			lines.forEach(line => {
				line = line.trim();
				if (line.startsWith('//')) {
					if (line.toLowerCase().includes('egg deck')) {currentDeckType = "Egg";} else {currentDeckType = "Deck";}
					return;}
				const firstChar = line.charAt(0);
				if (!isNaN(firstChar)) {
					const parts = line.split(' ');
					const numCards = parseInt(firstChar);
					const cardCode = parts[parts.length - 1].toUpperCase().trim();
					if (!isNaN(numCards) && cardCode) {
						for (let i = 0; i < numCards; i++) {
							cardEntries.push({ code: cardCode, type: currentDeckType });}}}});
			const shuffle = array => array.sort(() => Math.random() - 0.5);
			for (let i = 0; i < 3; i++) {shuffle(cardEntries);}
			cardEntries.forEach(entry => {
				addCards(1, entry.code, entry.type);});
			popup.style.display = 'none';
	});
    clearDeckButton.addEventListener('click', () => {
        const elements = container.children;
        for (let i = elements.length - 1; i >= 0; i--) {
            const element = elements[i];
            if (!element.src.includes(diceUrl)) {
                container.removeChild(element);}}
    });
	mulliganButton.addEventListener('click', () => {
		const cards = Array.from(container.children).filter(child => !child.src.includes(diceUrl));
		const containerWidth = container.offsetWidth;
		const containerHeight = container.offsetHeight;
		const raisingAreaCards = [];
		const nonRaisingAreaCards = [];
		const RaisingArea = {
			left: containerWidth * 0.13,
			right: containerWidth * 0.19,
			top: containerHeight * 0.87,
			bottom: containerHeight * 1
		};
		cards.forEach(card => {
			const cardRect = card.getBoundingClientRect();
			const containerRect = container.getBoundingClientRect();
			const cardLeft = cardRect.left - containerRect.left;
			const cardTop = cardRect.top - containerRect.top;
			const cardRight = cardLeft + card.offsetWidth;
			const cardBottom = cardTop + card.offsetHeight;
			const inRaisingArea = cardRight > RaisingArea.left && cardLeft < RaisingArea.right &&
								  cardBottom > RaisingArea.top && cardTop < RaisingArea.bottom;
			if (inRaisingArea) {raisingAreaCards.push(card);} else {nonRaisingAreaCards.push(card);}
		});
		shuffleArray(raisingAreaCards);
		raisingAreaCards.forEach(card => {
			card.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
			card.style.transform = 'rotate(0deg)';
			EggDeck(card);
		});
		shuffleArray(nonRaisingAreaCards);
		const securityCards = nonRaisingAreaCards.slice(0, 5);
		const handCards = nonRaisingAreaCards.slice(5, 10);
		const mainDeckCards = nonRaisingAreaCards.slice(10);
		securityCards.forEach(card => {
			card.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
			card.style.transform = 'rotate(-90deg)';
		});
		MoveTo(securityCards, {
			left: containerWidth * 0.04,
			top: containerHeight * 0.18,
			xSpacing: 0.05,
			ySpacing: 0.22
		});
		handCards.forEach(card => {
			card.src = card.dataset.originalImageUrl;
			card.style.transform = 'rotate(0deg)';
		});
		MoveTo(handCards, {
			left: containerWidth * 0.5,
			top: containerHeight * 0.84,
			xSpacing: 0.9,
			ySpacing: 0
		});
		mainDeckCards.forEach(card => {
			card.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
			card.style.transform = 'rotate(0deg)';
			MainDeck(card);
		});
});
	function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}
	function MoveTo(cards, area) {
    cards.forEach((card, i) => {
		let highestZIndex = 1;
        const cardWidth = card.offsetWidth;
        const cardHeight = card.offsetHeight;
        const positionX = area.left + (i * (cardWidth * area.xSpacing));
        const positionY = area.top + (i * (cardHeight * area.ySpacing));
        card.style.transition = 'left 0s ease, top 0s ease'; 
        card.style.left = `${positionX}px`;
        card.style.top = `${positionY}px`;
		card.style.zIndex = highestZIndex;
        card.addEventListener('transitionend', () => {
            updateCardPosition(card);
        }, { once: true });
    });
}
function addCards(num, code, type) {
    const apiUrl = `https://digimoncard.io/api/search.php?card=${code}`;
    function fetchCardDescription() {
        return fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(apiUrl))
            .then(response => response.text())
            .then(responseText => {
                const data = JSON.parse(responseText);
                if (data.length > 0) {
                    const cardData = data[0];
                    return {
                        name: cardData.name,
                        main_effect: cardData.main_effect,
                        source_effect: cardData.source_effect
                    };
                } else {
                    return {
                        name: 'Unknown',
                        main_effect: 'No effect available',
                        source_effect: 'No effect available'
                    };
                }
            })
            .catch(() => ({
                name: 'Error',
                main_effect: 'Failed to fetch effect',
                source_effect: 'Failed to fetch effect'
            }));}
    function createCard(description) {
        const card = document.createElement('img');
        const imageUrl = `https://images.digimoncard.io/images/cards/${code}.jpg`;
        const img = new Image();
        img.src = imageUrl;
        img.onload = function() {
            card.src = imageUrl;
            card.dataset.originalImageUrl = imageUrl;
            card.dataset.name = description.name;
            card.dataset.mainEffect = description.main_effect;
            card.dataset.sourceEffect = description.source_effect;
            if (type === 'Egg') {
                EggDeck(card);
            } else {
                MainDeck(card);
            }
            setupCardTooltips(card);
        };
        img.onerror = function() {
            card.src = defaultImageUrl;
            card.dataset.originalImageUrl = defaultImageUrl;
            card.dataset.name = description.name;
            card.dataset.mainEffect = description.main_effect;
            card.dataset.sourceEffect = description.source_effect;
            if (type === 'Egg') {
                EggDeck(card);
            } else {
                MainDeck(card);
            }
            setupCardTooltips(card);
        };
        card.className = 'card';
        card.style.width = (window.innerWidth / 10) + 'px';
        card.style.height = 'auto';
        container.appendChild(card);
        makeDraggable(card);
    }
    fetchCardDescription().then(description => {
        for (let i = 0; i < num; i++) {
            createCard(description);
        }
    });
    popup.style.display = 'none';
}
    function MainDeck(card) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const cardWidth = card.offsetWidth;
        const cardHeight = card.offsetHeight;
        const defaultCenterXRatio = 0.875;
        const defaultCenterYRatio = 0.14;
        const defaultCenterX = containerWidth * defaultCenterXRatio;
        const defaultCenterY = containerHeight * defaultCenterYRatio;
        card.dataset.defaultCenterXRatio = defaultCenterXRatio;
        card.dataset.defaultCenterYRatio = defaultCenterYRatio;
        card.dataset.visualLeftRatio = defaultCenterXRatio;
        card.dataset.visualTopRatio = defaultCenterYRatio;
        updateCardPosition(card);
    }
	function EggDeck(card) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const cardWidth = card.offsetWidth;
        const cardHeight = card.offsetHeight;
        const defaultCenterXRatio = 0.065;
        const defaultCenterYRatio = 0.708;
        const defaultCenterX = containerWidth * defaultCenterXRatio;
        const defaultCenterY = containerHeight * defaultCenterYRatio;
        card.dataset.defaultCenterXRatio = defaultCenterXRatio;
        card.dataset.defaultCenterYRatio = defaultCenterYRatio;
        card.dataset.visualLeftRatio = defaultCenterXRatio;
        card.dataset.visualTopRatio = defaultCenterYRatio;
        updateCardPosition(card);
    }
    function updateCardPosition(card) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const defaultCenterXRatio = parseFloat(card.dataset.defaultCenterXRatio);
        const defaultCenterYRatio = parseFloat(card.dataset.defaultCenterYRatio);
        const visualLeftRatio = parseFloat(card.dataset.visualLeftRatio);
        const visualTopRatio = parseFloat(card.dataset.visualTopRatio);
        const cardWidth = card.offsetWidth;
        const cardHeight = card.offsetHeight;
        const newX = visualLeftRatio * containerWidth - defaultCenterXRatio;
        const newY = visualTopRatio * containerHeight - defaultCenterYRatio;
        card.style.left = newX + 'px';
        card.style.top = newY + 'px';
    }
	function checkCardRegion(card) {
    const container = document.getElementById('drag-container');
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight;
    const cardRect = card.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const cardLeft = cardRect.left - containerRect.left;
    const cardTop = cardRect.top - containerRect.top;
    const cardRight = cardLeft + card.offsetWidth;
    const cardBottom = cardTop + card.offsetHeight;
    const SecurityArea = {
        left: 0,
        right: containerWidth * 0.12,
        top: containerHeight * 0.3,
        bottom: containerHeight * 0.45
    };
    const DeckArea = {
        left: containerWidth * 0.92,
        right: containerWidth * 1,
        top: containerHeight * 0.25,
        bottom: containerHeight * 0.27
    };
    const EggArea = {
        left: containerWidth * 0.13,
        right: containerWidth * 0.11,
        top: containerHeight * 0.87,
        bottom: containerHeight * 1
    };
	const RaisingArea = {
        left: containerWidth * 0.13,
        right: containerWidth * 0.19,
        top: containerHeight * 0.87,
        bottom: containerHeight * 1
    };
	const TrashArea = {
        left: containerWidth * 0.92,
        right: containerWidth * 1,
        top: containerHeight * 0.25,
        bottom: containerHeight * 0.60
    };
	const inSecurityArea = cardRight > SecurityArea.left && cardLeft < SecurityArea.right &&
                      cardBottom > SecurityArea.top && cardTop < SecurityArea.bottom;
    const inDeckArea = cardRight > DeckArea.left && cardLeft < DeckArea.right &&
                      cardBottom > DeckArea.top && cardTop < DeckArea.bottom;
    const inEggArea = cardRight > EggArea.left && cardLeft < EggArea.right &&
                      cardBottom > EggArea.top && cardTop < EggArea.bottom;
	const inRaisingArea = cardRight > RaisingArea.left && cardLeft < RaisingArea.right &&
                      cardBottom > RaisingArea.top && cardTop < RaisingArea.bottom;
	const inTrashArea = cardRight > TrashArea.left && cardLeft < TrashArea.right &&
                      cardBottom > TrashArea.top && cardTop < TrashArea.bottom;
    if (inSecurityArea || inDeckArea || inEggArea) {
		card.src = defaultImageUrl;} else {card.src = card.dataset.originalImageUrl || defaultImageUrl;}
    if (inSecurityArea) {
        let rotation = parseInt(card.style.transform.replace('rotate(', '').replace('deg)', '')) || 0;
        if (rotation % 360 === 0) {rotation -= 90;}
        rotation = (rotation - 360) % 360;
        card.style.transform = `rotate(${rotation}deg)`;}
	if (inRaisingArea || inTrashArea) {
        let rotation = parseInt(card.style.transform.replace('rotate(', '').replace('deg)', '')) || 0;
        if (rotation % 360 === 0) {rotation -= 0;} else {rotation += 90;}
        rotation = (rotation - 360) % 360;
        card.style.transform = `rotate(${rotation}deg)`;
    }
}
    let highestZIndex = 1;
    function makeDraggable(element) {
    let isMoving = false;
    let startX, startY, initialX, initialY;
    element.addEventListener('mousedown', (e) => {
        isMoving = true;
        startX = e.clientX;
        startY = e.clientY;
        initialX = element.offsetLeft;
        initialY = element.offsetTop;
        highestZIndex++;
        element.style.zIndex = highestZIndex;
        document.addEventListener('mousemove', moveElement);
        document.addEventListener('mouseup', stopMove);
    });
        function moveElement(e) {
        if (isMoving) {
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const newX = initialX + dx;
            const newY = initialY + dy;
            const minY = 0;
            const maxX = container.offsetWidth - element.offsetWidth;
            const maxY = 1.1 * container.offsetHeight - element.offsetHeight;
            if (newX >= 0 && newX <= maxX && newY >= minY && newY <= maxY) {
                element.style.left = newX + 'px';
                element.style.top = newY + 'px';
                const visualLeftRatio = newX / container.offsetWidth;
                const visualTopRatio = newY / container.offsetHeight;
                element.dataset.visualLeftRatio = visualLeftRatio;
                element.dataset.visualTopRatio = visualTopRatio;
                checkCardRegion(element);
            }
        }
    }
    function stopMove() {
        isMoving = false;
        document.removeEventListener('mousemove', moveElement);
        document.removeEventListener('mouseup', stopMove);
    }
    element.addEventListener('dblclick', () => {
		const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
		const cardRect = element.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        const cardLeft = cardRect.left - containerRect.left;
        const cardTop = cardRect.top - containerRect.top;
        const cardRight = cardLeft + element.offsetWidth;
        const cardBottom = cardTop + element.offsetHeight;
        const TrashArea = {
            left: containerWidth * 0.92,
            right: containerWidth * 1,
            top: containerHeight * 0.25,
            bottom: containerHeight * 0.60
        };
		const inTrashArea = cardRight > TrashArea.left && cardLeft < TrashArea.right &&
                            cardBottom > TrashArea.top && cardTop < TrashArea.bottom;
        let rotation = parseInt(element.style.transform.replace('rotate(', '').replace('deg)', '')) || 0;
         if (inTrashArea) {
			element.style.transform = 'rotate(0deg)';
            MainDeck(element);
            element.style.zIndex = 1;
			element.src = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Back.png';
		} else {
		if (rotation % 360 === 0) {
            rotation -= 90;
        } else {
            rotation += 90;
        }}
        rotation = (rotation - 360) % 360;
        element.style.transform = `rotate(${rotation}deg)`;
    });
	 element.dataset.originalImageUrl = element.src;
    }
    function addDice() {
        const dice = document.createElement('img');
        dice.src = diceUrl;
        dice.className = 'card';
        dice.style.width = (window.innerWidth / 25) + 'px';
        dice.style.height = 'auto';
        dice.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
        container.appendChild(dice);
        makeDraggable(dice);
        centerDice(dice);
    }
    function centerDice(dice) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const diceWidth = dice.offsetWidth;
        const diceHeight = dice.offsetHeight;
        const defaultCenterXRatio = 0.483;
        const defaultCenterYRatio = 0.024;
        dice.dataset.defaultCenterXRatio = defaultCenterXRatio;
        dice.dataset.defaultCenterYRatio = defaultCenterYRatio;
        dice.dataset.visualLeftRatio = defaultCenterXRatio;
        dice.dataset.visualTopRatio = defaultCenterYRatio;
        updateDicePosition(dice);
    }
    function updateDicePosition(dice) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const defaultCenterXRatio = parseFloat(dice.dataset.defaultCenterXRatio);
        const defaultCenterYRatio = parseFloat(dice.dataset.defaultCenterYRatio);
        const visualLeftRatio = parseFloat(dice.dataset.visualLeftRatio);
        const visualTopRatio = parseFloat(dice.dataset.visualTopRatio);
        const diceWidth = dice.offsetWidth;
        const diceHeight = dice.offsetHeight;
        const newX = visualLeftRatio * containerWidth - defaultCenterXRatio;
        const newY = visualTopRatio * containerHeight - defaultCenterYRatio;
        dice.style.left = newX + 'px';
        dice.style.top = newY + 'px';
    }
    function adjustCardSize() {
        const cards = document.querySelectorAll('.card');
        cards.forEach(card => {
            if (!card.src.includes(diceUrl)) { 
                card.style.width = (window.innerWidth / 10) + 'px';
                updateCardPosition(card);
            }
        });
    }
    function adjustDiceSize() {
        const dice = document.querySelectorAll('.card'); 
        dice.forEach(d => {
            if (d.src.includes(diceUrl)) { 
                d.style.width = (window.innerWidth / 25) + 'px';
                updateDicePosition(d);
            }
        });
    }
    function adjustContainerSize() {
        const backgroundImg = 'https://github.com/DracoFabz/DracoFabz.github.io/raw/main/Layout.png';
        const img = new Image();
        img.src = backgroundImg;
        img.onload = function() {
            const imgWidth = img.width;
            const imgHeight = img.height;
            container.style.width = `calc(100% - 10px)`;
            container.style.height = `calc((100vw / ${imgWidth}) * ${imgHeight})`;
            Array.from(container.getElementsByClassName('card')).forEach(element => {
                if (element.src.includes(diceUrl)) {
                    updateDicePosition(element);
                } else {
                    updateCardPosition(element);
                }
            });
        };
    }
	function adjustButtonBanner() {
        const banner = document.getElementById('banner');
        const buttonsBanner = document.getElementById('buttons-banner');
        const bannerHeight = banner.offsetHeight;
        const buttons = document.querySelectorAll('.button');
        buttonsBanner.style.top = `${bannerHeight + 10}px`;
        buttonsBanner.style.height = `${bannerHeight}px`;
        buttons.forEach(button => {
            button.style.height = `${0.7 * bannerHeight}px`;
            button.style.lineHeight = `${0.7 * bannerHeight}px`;
            button.style.fontSize = `${0.35 * bannerHeight}px`;
        });
    }
	
    window.addEventListener('resize', () => {
        requestAnimationFrame(() => {
            adjustCardSize();
            adjustDiceSize();
            adjustContainerSize();
            adjustButtonBanner();
        });
    });
    document.addEventListener('DOMContentLoaded', () => {
        adjustCardSize();
        adjustDiceSize();
        adjustContainerSize();
        adjustButtonBanner();
        addDice(); 
    });
	
	function setupCardTooltips(card) {
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
    let hoverTimeout;
    function showTooltip(event) {
        hoverTimeout = setTimeout(() => {
            const card = event.currentTarget;
            if (card.dataset.originalImageUrl !== defaultImageUrl) {
                tooltip.innerHTML = '`<strong>Name:</strong> ${card.dataset.name}<br><strong>Main Effect:</strong> ${card.dataset.mainEffect}<br><strong>Source Effect:</strong> ${card.dataset.sourceEffect}`';
                const rect = card.getBoundingClientRect();
                tooltip.style.left = `${rect.right + 10}px`;
                tooltip.style.top = `${rect.top}px`;
                tooltip.classList.add('show');
            }
        }, 3000);
    }
    function hideTooltip() {
        clearTimeout(hoverTimeout);
        tooltip.classList.remove('show');
    }
    card.addEventListener('mouseenter', showTooltip);
    card.addEventListener('mouseleave', hideTooltip);
}
	
</script>
</body>
</html>